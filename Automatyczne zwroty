/********** KONFIGURACJA **********/
const CONFIG = {
  MASTER_SHEET_ID: '1q_mPf8dxpQXoDWnaF9fOZlrbpIDR7IKX_gZSGYNl0fg',
  LABEL_NEW: 'Zwroty',
  LABEL_DONE_ROOT: 'Zwroty zrobione'
};
/**********************************/

function main() {
  processReturnsWithRomanLabels();
}

function processReturnsWithRomanLabels() {
  const labelNew = GmailApp.getUserLabelByName(CONFIG.LABEL_NEW);
  if (!labelNew) {
    Logger.log('‚ùå Nie znaleziono etykiety: ' + CONFIG.LABEL_NEW);
    return;
  }

  const threads = labelNew.getThreads();
  if (threads.length === 0) {
    Logger.log('üì≠ Brak maili z etykietƒÖ: ' + CONFIG.LABEL_NEW);
    return;
  }

  // Przygotowanie daty
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, '0');
  const dd = String(today.getDate()).padStart(2, '0');

  // Sprawd≈∫, ile raport√≥w z dzisiejszƒÖ datƒÖ ju≈º istnieje
  const ss = SpreadsheetApp.openById(CONFIG.MASTER_SHEET_ID);
  const sheets = ss.getSheets();
  const dateBaseName = `${dd}.${mm}.${yyyy}`;

  // Filtruj arkusze, kt√≥re zaczynajƒÖ siƒô od tej daty
  const existingSheets = sheets
    .map(s => s.getName())
    .filter(n => n.startsWith(dateBaseName));

  let suffix = '';
  if (existingSheets.length > 0) {
    suffix = ' ' + toRoman(existingSheets.length + 1);
  }

  const finalSheetName = dateBaseName + suffix;
  Logger.log(`üìÑ Tworzenie arkusza: ${finalSheetName}`);

  // Przygotowanie etykiety Gmail (z tym samym numerem rzymskim)
  let labelSuffix = '';
  if (existingSheets.length > 0) {
    labelSuffix = ' ' + toRoman(existingSheets.length + 1);
  }

  const doneLabelName = `${CONFIG.LABEL_DONE_ROOT}/${yyyy}-${mm}-${dd}${labelSuffix}`;
  let labelDone = GmailApp.getUserLabelByName(doneLabelName);
  if (!labelDone) labelDone = GmailApp.createLabel(doneLabelName);

  // Obiekt do sumowania danych po SKU
  const mergedData = {};

  threads.forEach(thread => {
    const messages = thread.getMessages();
    messages.forEach(msg => {
      const attachments = msg.getAttachments();
      attachments.forEach(att => {
        if (att.getName().toLowerCase().endsWith('.csv')) {
          let text;
          try {
            text = att.getDataAsString('utf-8');
          } catch (e) {
            text = att.getDataAsString('windows-1250');
          }

          const delim = detectDelimiter(text);
          const rows = Utilities.parseCsv(text, delim);
          const fileName = att.getName();

          // Pomijamy pierwszy wiersz (nag≈Ç√≥wki)
          for (let i = 1; i < rows.length; i++) {
            const sku = rows[i][0] ? rows[i][0].trim() : '';
            const name = rows[i][1] ? rows[i][1].trim() : '';
            const qty = rows[i][3] ? Number(rows[i][3]) : 0;

            if (!sku || isNaN(qty)) continue;

            if (mergedData[sku]) {
              mergedData[sku].quantity += qty;
              if (!mergedData[sku].files.includes(fileName)) {
                mergedData[sku].files.push(fileName);
              }
            } else {
              mergedData[sku] = {
                quantity: qty,
                product: name,
                files: [fileName]
              };
            }
          }
        }
      });
    });

    // Oznacz mail jako przeczytany i zaktualizuj etykiety
    thread.markRead();
    thread.removeLabel(labelNew);
    thread.addLabel(labelDone);
  });

  // Tworzenie arkusza
  const sheet = ss.insertSheet(finalSheetName);
  const output = [['Product', 'SKU', 'Quantity', 'Source File']];

  for (const sku in mergedData) {
    output.push([
      mergedData[sku].product,
      sku,
      mergedData[sku].quantity,
      mergedData[sku].files.join(', ')
    ]);
  }

  if (output.length > 1) {
    sheet.getRange(1, 1, output.length, output[0].length).setValues(output);
    Logger.log(`‚úÖ Zapisano dane do arkusza: ${finalSheetName}`);
  } else {
    Logger.log('‚ö†Ô∏è Nie znaleziono ≈ºadnych danych CSV do zapisania.');
  }

  Logger.log(`üè∑Ô∏è Maile przeniesione do etykiety: ${doneLabelName}`);
}

/* Pomocnicza funkcja: wykrywanie separatora CSV */
function detectDelimiter(text) {
  const firstLine = text.split(/\r?\n/)[0] || '';
  const comma = (firstLine.match(/,/g) || []).length;
  const semi = (firstLine.match(/;/g) || []).length;
  return semi > comma ? ';' : ',';
}

/* Pomocnicza funkcja: konwersja liczb na cyfry rzymskie */
function toRoman(num) {
  const romans = [
    ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400],
    ['C', 100], ['XC', 90], ['L', 50], ['XL', 40],
    ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1]
  ];
  let result = '';
  for (let [letter, value] of romans) {
    while (num >= value) {
      result += letter;
      num -= value;
    }
  }
  return result;
}
